Index: joni/trunk/src/org/joni/NameEntry.java
===================================================================
diff -u -N -r5517 -r6634
--- joni/trunk/src/org/joni/NameEntry.java	(.../NameEntry.java)	(revision 5517)
+++ joni/trunk/src/org/joni/NameEntry.java	(.../NameEntry.java)	(revision 6634)
@@ -22,9 +22,9 @@
 public final class NameEntry {
     static final int INIT_NAME_BACKREFS_ALLOC_NUM = 8;
     
-    final byte[]name;
-    final int nameP;
-    final int nameEnd;
+    public final byte[]name;
+    public final int nameP;
+    public final int nameEnd;
     
     int backNum;
     int backRef1;
@@ -35,7 +35,20 @@
         nameP = p;
         nameEnd = end;
     }
-    
+
+    public int[] getBackRefs() {
+        switch (backNum) {
+        case 0:
+            return new int[]{};
+        case 1:
+            return new int[]{backRef1};
+        default:
+            int[]result = new int[backNum];
+            System.arraycopy(backRefs, 0, result, 0, backNum);
+            return result;
+        }
+    }    
+
     private void alloc() {
         backRefs = new int[INIT_NAME_BACKREFS_ALLOC_NUM];
     }
Index: joni/trunk/src/org/joni/Regex.java
===================================================================
diff -u -N -r6090 -r6634
--- joni/trunk/src/org/joni/Regex.java	(.../Regex.java)	(revision 6090)
+++ joni/trunk/src/org/joni/Regex.java	(.../Regex.java)	(revision 6634)
@@ -24,6 +24,7 @@
 import static org.joni.Option.isDontCaptureGroup;
 
 import java.util.IllegalFormatConversionException;
+import java.util.Iterator;
 
 import org.joni.constants.AnchorType;
 import org.joni.constants.RegexState;
@@ -183,10 +184,10 @@
         }
     }    
 
-    int numberOfNames() {
+    public int numberOfNames() {
         return nameTable == null ? 0 : nameTable.size();
     }
-    
+
     void nameAdd(byte[]name, int nameP, int nameEnd, int backRef, Syntax syntax) {
         if (nameEnd - nameP <= 0) throw new ValueException(ErrorMessages.ERR_EMPTY_GROUP_NAME);
 
@@ -207,12 +208,11 @@
 
         e.addBackref(backRef);
     }
-    
+
     NameEntry nameToGroupNumbers(byte[]name, int nameP, int nameEnd) {
-        NameEntry e = nameFind(name, nameP, nameEnd);
-        return e;
+        return nameFind(name, nameP, nameEnd);
     }
-    
+
     public int nameToBackrefNumber(byte[]name, int nameP, int nameEnd, Region region) {
         NameEntry e = nameToGroupNumbers(name, nameP, nameEnd);
         if (e == null) throw new ValueException(ErrorMessages.ERR_UNDEFINED_NAME_REFERENCE,
@@ -233,8 +233,12 @@
             return e.backRefs[e.backNum - 1];
         }
     }
-        
-    boolean noNameGroupIsActive(Syntax syntax) {
+
+    public Iterator<NameEntry> namedBackrefIterator() {
+        return nameTable.iterator();
+    }
+
+    public boolean noNameGroupIsActive(Syntax syntax) {
         if (isDontCaptureGroup(options)) return false;
         
         if (Config.USE_NAMED_GROUP) {
@@ -249,11 +253,11 @@
         int p = exactP;
         int end = exactEnd;
         int len = end - p;
-        if (map == null) map = new byte[Config.CHAR_TABLE_SIZE]; // ?? but seems to be safe
-        
-        // map/skip
-        
+
         if (len < Config.CHAR_TABLE_SIZE) {
+            // map/skip
+            if (map == null) map = new byte[Config.CHAR_TABLE_SIZE];
+
             for (int i=0; i<Config.CHAR_TABLE_SIZE; i++) map[i] = (byte)len;
             for (int i=0; i<len-1; i++) map[bytes[p + i] & 0xff] = (byte)(len - 1 -i); // oxff ??
         } else {
